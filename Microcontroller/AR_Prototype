// Подключение заголовочного файла для работы с интерфейсом SPI, который необходим для передачи данных между Arduino и RFID-модулем RC522
#include <SPI.h>
// Подключение заголовочного файла для работы с RFID-модулем RC522
#include <MFRC522.h>

// Определение пинов, необходимых для инициализации переменной типа MFRC522
#define RST_PIN 5 
#define SS_PIN	53
// Определение пина, с помощью которого управляется замок
#define LOCK_PIN 44

/*
 * Инструкция по подключению модуля RC522 к Arduino Mega:
 * -----------------------------------
 *             MFRC522      Arduino   
 *             Reader/PCD   Mega      
 * Signal      Pin          Pin       
 * -----------------------------------
 * RST/Reset   RST          5         
 * SPI SS      SDA(SS)      53        
 * SPI MOSI    MOSI         51        
 * SPI MISO    MISO         50        
 * SPI SCK     SCK          52        
*/

// Список используемых команд
// '0' : Команда подтверждения установки соединения Arduino и компьютера
// '1' : Команда разрыва соединения между Arduino и компьютером
// '2' : Команда, получаемая при прикладывании пропуска и свидетельствующая о том, что доступ разрешен
// '3' : Команда, получаемая при прикладывании пропуска и свидетельствующая о том, что доступ запрещен
// '4' : Команда, получаемая при повторном прикладывании пропуска и свидетельствующая об окончании работы пользователя с системой
// '5' : Команда, получаемая при прикладывании ценности и свидетельствующая о ее взятии
// '6' : Команда, получаемая при прикладывании ценности и свидетельствующая о ее возврате
// '7' : Команда, получаемая при прикладывании ценности, данные о которой отсутствуют в базе
#define COMMAND_CONNECT        '0'
#define COMMAND_DISCONNECT     '1'
#define COMMAND_VALID_PASS     '2'
#define COMMAND_INVALID_PASS   '3'
#define COMMAND_END_SESSION    '4'
#define COMMAND_VALUE_TAKEN    '5'
#define COMMAND_VALUE_RETURNED '6'
#define COMMAND_INVALID_VALUE  '7'

// Создание переменной типа MFRC522, т.е RFID-метки
MFRC522 rfid(SS_PIN, RST_PIN);

void setup() {
/*
 * Функция установки, вызывается при подаче питания на Arduino и нажатии кнопки RESET. Также может быть вызвана в других функциях. Выполняется 1 раз.
 * Входных парамеров нет
 * Выходных параметров нет
*/
  // Открытие последовательного COM-порта, необходимого для обмена данными между компьютером и Arduino по протоколу UART
  Serial.begin(9600);
  // Ожидание открытия COM-порта
  while (!Serial) {
    delay(10);
  }
 
  // Открытие взаимодействия по интерфейсу SPI
  SPI.begin();
  
  // Инициализация переменной типа MFRC522
  rfid.PCD_Init();
  
  // Настройка индикации наличия подключения
  pinMode(LED_BUILTIN, OUTPUT);
  ledOff();
  
  // Настройка состояния замка 
  lock();
}

void loop() {
/*
 * Функция описывает постоянно выполняемые в бесконечном цикле действия. После завершения вызывается снова.
 * Входных параметров нет
 * Выходных параметров нет
*/
  // Ожидание команды
  waitingForCommand();
  
  // Считывание команды после ее получения
  int command = Serial.read();
  // Пропуск символов новой строки при их наличии. Требуется для дальнейшей корректной работы
  skipNewLine();

  // Выбор действия в зависимости от полученной команды
  switch (command) {
    // Получена команда установки подключения
    case COMMAND_CONNECT:
      // Включение индикации, сигнализирующей о наличии подключения
      ledOn();
      // Переход к ожиданию RFID-метки (пропуска)
      readRFID();
      break;

    // Получена команда разрыва соединения
    case COMMAND_DISCONNECT:
      // Выключение индикации, сигнализирующей о наличии подключения
      ledOff();
      break;

    // При прикладывании пропуска и разрешении доступа
    case COMMAND_VALID_PASS:
      //Открытие замка
      unlock();
      // Переход к ожиданию RFID-метки (ценности или пропуска, которым система была открыта)
      readRFID();
      break;

    // При прикладывании пропуска и запрете доступа
    case COMMAND_INVALID_PASS:
      // Переход к ожиданию RFID-метки (пропуска)
      readRFID();
      break;

    // При повторном прикладывании пропуска
    case COMMAND_END_SESSION:
      //Закрытие замка
      lock();
      // Переход к ожиданию RFID-метки (пропуска)
      readRFID();
      break;
      
    // При взятии ценности  
    case COMMAND_VALUE_TAKEN:
      // Переход к ожиданию RFID-метки (ценности или пропуска, которым система была открыта)
      readRFID();
      break;
      
    // При возврате ценности  
    case COMMAND_VALUE_RETURNED:
      // Переход к ожиданию RFID-метки (ценности или пропуска, которым система была открыта)
      readRFID();
      break;

    // При неизвестной ценности
    case COMMAND_INVALID_VALUE:
      // Переход к ожиданию RFID-метки (ценности или пропуска, которым система была открыта)
      readRFID();
      break;
      
    // При получении неизвестной команды или ошибке в системе
    default:
      // Сигнализация об ошибке
      for (int i = 0; i < 5; ++i) {
        ledOff();
        delay(100);
        ledOn();
        delay(100);
      }
      // Сигнализация о разрыве соединения
      ledOff();
  }
}

void ledOn() {
/*
 * Функция, включающая индикацию при установке соединения. 
 * Входных параметров нет
 * Выходных параметров нет
*/
  digitalWrite(LED_BUILTIN, HIGH);
}

void ledOff() {
/*
 * Функция, выключающая индикацию при разрыве соединения. 
 * Входных параметров нет
 * Выходных параметров нет
*/
  digitalWrite(LED_BUILTIN, LOW);
}

void serialClear() {
/*
 * Функция для очистки входного буфера последовательного порта 
 * Входных параметров нет
 * Выходных параметров нет
*/
  while (Serial.available()) {
    Serial.read();
  }
}

void waitingForCommand() {
/*
 * Функция ожидания получения команды из последовательного порта
 * Входных параметров нет
 * Выходных параметров нет
*/
  while (!(Serial.available())) {
    delay(100);
  }
}

bool waitingForRFID() {
/*
 * Функция ожидания RFID-метки 
 * Входных параметров нет
 * Выходной параметр типа bool показывает, был ли выход из режима ожидания связан с нахождением RFID-метки. TRUE если да, FALSE в противном случае
*/
  // Ожидание пока нет метки в зоне считывания, или пока метку не удается считать, или пока не пришла новая команда
  while (((!(rfid.PICC_IsNewCardPresent())) || (!(rfid.PICC_ReadCardSerial()))) && (!(Serial.available()))) {
    delay(100);
  }
  
  // Выход в связи с получением новой команды
  if (Serial.available()) {
    return false;
  }
  // Метка найдена, считывание возможно
  else {
    return true;
  }
}

void readRFID() {
/*
 * Функция, осуществляющая чтение UID метки и отправку его по COM-порту, если метка была найдена
 * Входных параметров нет
 * Выходных параметров нет
*/
  // Ожидание метки
  bool rfidFound = waitingForRFID();
  
  // Если метка была найдена и считывание возможно
  if (rfidFound) {
    // Чтение размера UID, самого UID и отправка его по COM-порту
    Serial.println(rfid.uid.size);
    for (byte i = 0; i < rfid.uid.size; ++i) {
      Serial.println(rfid.uid.uidByte[i], HEX);
    }
    // Остановка процесса чтения
    rfid.PICC_HaltA();
    delay(1000);
  }

  // В случае, когда метка не найдена, просто происходит выход из функции
}

void skipNewLine() {
/*
 * Функция, предназначенная для пропуска символов новой строки в буфере последовательного порта для чтения
 * Входных параметров нет
 * Выходных параметров нет
*/
  while (Serial.peek() == 10) {
    // 10 - код '\n'
    Serial.read(); 
  }
}

void unlock() {
/*
 * Функция, предназначенная для открытия замка
 * Входных параметров нет
 * Выходных параметров нет
*/
  digitalWrite(LOCK_PIN, HIGH);
}

void lock() {
/*
 * Функция, предназначенная для закрытия замка
 * Входных параметров нет
 * Выходных параметров нет
*/
  digitalWrite(LOCK_PIN, LOW);
}
